#Test module, generated by chat gpt to allow testing with the arduino in place of a Ros node

import serial
import time
import re

class ArduinoTester:
    def __init__(self, port, baudrate=9600, timeout=1):
        """
        Initialize the serial connection to the Arduino.
        """
        self.ser = serial.Serial(port, baudrate, timeout=timeout)
        # Wait for Arduino to reset after opening the serial port
        time.sleep(2)

    def send_command(self, command):
        """
        Send a command to the Arduino.
        """
        self.ser.write((command + '\n').encode('utf-8'))
        time.sleep(0.1)  # Short delay to ensure the command is processed

    def read_response(self):
        """
        Read all available responses from the Arduino.
        """
        responses = []
        while self.ser.in_waiting > 0:
            line = self.ser.readline().decode('utf-8').strip()
            if line:
                responses.append(line)
        return responses

    def parse_speeds(self, response):
        """
        Parse the left and right speeds from the Arduino's response.
        """
        match = re.search(r"Left Speed: ([\d\.-]+) Right Speed: ([\d\.-]+)", response)
        if match:
            left_speed = float(match.group(1))
            right_speed = float(match.group(2))
            return left_speed, right_speed
        return None, None

    def test_motor_update(self):
        """
        Test motorUpdate function by sending various speed commands.
        """
        print("Testing motorUpdate with various speed commands...")
        test_cases = [
            {"FB": 50, "LR": 0, "EN": 0},
            {"FB": -50, "LR": 0, "EN": 0},
            {"FB": 0, "LR": 50, "EN": 0},
            {"FB": 0, "LR": -50, "EN": 0},
            {"FB": 100, "LR": 100, "EN": 0},
            {"FB": -100, "LR": -100, "EN": 0},
            {"FB": 100, "LR": -100, "EN": 0},
            {"FB": -100, "LR": 100, "EN": 0},
            {"FB": 0, "LR": 0, "EN": 0},
        ]
        for test in test_cases:
            cmd = f"FB:{test['FB']} LR:{test['LR']} EN:{test['EN']}"
            self.send_command(cmd)
            time.sleep(0.1)
            responses = self.read_response()
            print(f"\nCommand Sent: {cmd}")
            for response in responses:
                print(f"Arduino Response: {response}")
                left_speed, right_speed = self.parse_speeds(response)
                if left_speed is not None and right_speed is not None:
                    # Add any assertions or checks here if needed
                    pass

    def test_track_control(self):
        """
        Test trackCntrl function by enabling traction control.
        """
        print("\nTesting trackCntrl with traction control enabled...")
        test_cases = [
            {"FB": 50, "LR": 0, "EN": 1},
            {"FB": -50, "LR": 0, "EN": 1},
            {"FB": 0, "LR": 50, "EN": 1},
            {"FB": 0, "LR": -50, "EN": 1},
        ]
        for test in test_cases:
            cmd = f"FB:{test['FB']} LR:{test['LR']} EN:{test['EN']}"
            self.send_command(cmd)
            time.sleep(0.1)
            responses = self.read_response()
            print(f"\nCommand Sent: {cmd}")
            for response in responses:
                print(f"Arduino Response: {response}")

    def test_invalid_inputs(self):
        """
        Test how the Arduino handles invalid inputs.
        """
        print("\nTesting invalid inputs...")
        invalid_commands = [
            "FB:abc LR:0 EN:0",
            "FB:100 LR:abc EN:0",
            "FB:100 LR:0 EN:xyz",
            "FB:200 LR:0 EN:0",     # Out of range
            "FB:-200 LR:0 EN:0",    # Out of range
            "FB:100 LR:0 EN:2",     # Invalid EN value
            "FB LR:0 EN:0",         # Missing FB value
            "LR:50 EN:0",           # Missing FB command
            "EN:0",                 # Missing FB and LR
            "",                     # Empty command
        ]
        for cmd in invalid_commands:
            self.send_command(cmd)
            time.sleep(0.1)
            responses = self.read_response()
            print(f"\nInvalid Command Sent: {cmd}")
            for response in responses:
                print(f"Arduino Response: {response}")

    def test_encoder_reading(self):
        """
        Test the encodeReading function.
        Note: encodeReading is not called in the loop; you may need to modify
        your Arduino code to call this function or to respond to a specific command.
        """
        print("\nTesting encodeReading function...")
        # Since encodeReading is not triggered by serial commands in your code,
        # you might need to implement a command like "CMD:ENCODEREAD" in your Arduino code.
        # For now, this function is a placeholder.
        pass

    def close(self):
        """
        Close the serial connection.
        """
        self.ser.close()

def main():
    # Replace 'COM3' with the correct port for your system
    port = 'COM3'  # For Windows, e.g., 'COM3'; For Unix, e.g., '/dev/ttyACM0'
    tester = ArduinoTester(port=port)

    try:
        tester.test_motor_update()
        tester.test_track_control()
        tester.test_invalid_inputs()
        tester.test_encoder_reading()
    finally:
        tester.close()

if __name__ == '__main__':
    main()
